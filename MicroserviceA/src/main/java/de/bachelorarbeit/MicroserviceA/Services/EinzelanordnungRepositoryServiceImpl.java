package de.bachelorarbeit.MicroserviceA.Services;

import de.bachelorarbeit.MicroserviceA.DB1.repositories.EinzelanordnungRepository;
import de.bachelorarbeit.MicroserviceA.DB1.entities.Einzelanordnung;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import java.net.ConnectException;
import java.util.List;
import java.util.Optional;

@Service
public class EinzelanordnungRepositoryServiceImpl implements EinzelanordnungRepositoryService{

    private EinzelanordnungRepository einzelanordnungRepository;

    Logger logger = LoggerFactory.getLogger(EinzelanordnungRepositoryServiceImpl.class);

    @Autowired
    public EinzelanordnungRepositoryServiceImpl(EinzelanordnungRepository einzelanordnungRepository) {
        this.einzelanordnungRepository = einzelanordnungRepository;
    }

    /**
     * saves given einzelanordnung in DB1
     * @param einzelanordnung
     * @return the saved einzelanordnung with its id generated by DB1, or null if anything goes wrong
     */
    @Override
    public Einzelanordnung save(Einzelanordnung einzelanordnung) {
        try{
            return einzelanordnungRepository.save(einzelanordnung);
        }catch (Exception exc){
            logger.error("ERROR STH WRONG WITH DB1");
            return null;
        }
    }

    /**
     *
     * @param id
     * @return null if einzelanordnung was not found in the db
     * @throws ConnectException if sth is wrong with DB1
     */
    @Override
    public Einzelanordnung findById(long id) throws ConnectException {
        Optional<Einzelanordnung> einzelanordnungOptional;
        try{
            einzelanordnungOptional = einzelanordnungRepository.findById(id);
        }catch (Exception exc){
            logger.error("ERROR STH WRONG WITH DB1 - Could not retrieve Einzelanordnung with id: " + id);
            throw new ConnectException();
        }

        if(einzelanordnungOptional.isPresent()){
            return einzelanordnungOptional.get();
        }
        logger.warn("WARN Einzelanordnung with id: " + id + " could not be found in DB1");
        return null;
    }

    /**
     *
     * @return Liste aller einzelanordnungen in DB1, leere liste, wenn keine Elemente gefunden,
     * @throws ConnectException wenn etwas mit DB1 nicht stimmt
     */
    @Override
    public List<Einzelanordnung> findAll() throws ConnectException {
        try{
            return einzelanordnungRepository.findAll();
        }catch (Exception exc){
            logger.error("ERROR STH WRONG WITH DB1");
            throw new ConnectException();
        }
    }

    /**
     * updates the received status of one einzelanordnung to true
     * @param id of the einzelanordnung
     * @return updated einzelanordnung if everything went well, null if the update was not possible
     */
    @Override
    public Einzelanordnung updateReceivedStatus(long id) {
        Einzelanordnung foundEinzelanordnung;
        try {
            foundEinzelanordnung = this.findById(id);
        } catch (ConnectException e) {
            logger.debug("ERROR could not update einzelanordnung received status");
            return null;
        }
        foundEinzelanordnung.setWasReceivedToTrue();
        return this.save(foundEinzelanordnung);
    }

    /**
     * liefert eine Liste aller Einzelanordnungen aus DB1 welche zwar schon unterschrieben wurden, für die aber noch keine Bestätigung von Msb
     * erhalten wurde
     * @return null wenn etwas mit der verbindung zu MSB nicht stimmt oder es keine noch nicht bestätigten Einzelanordnungen in DB1 gibt.
     */
    @Override
    public List<Einzelanordnung> findAllNotReceived() {
        try{
            return einzelanordnungRepository.findAllByWasReceivedByMSBIsFalse();
        }catch(Exception exc){
            logger.debug("ERROR sth is wrong with the connection to DB1 for catching all not yet received einzelanordnungen");
            return null;
        }
    }

    /**
     * flags DB1 entry because MSB recognized wrong signatures
     *
     * @param id of einzelanordnung that needs to be flagged
     * @return true if the einzelanordnung was flagged false if sth went wrong
     */
    @Override
    public boolean flag(long id){
        Einzelanordnung einzelanordnung = null;
        try {
            einzelanordnung = this.findById(id);
        } catch (ConnectException e) {
            logger.debug("Error Anordnung could not be flagged");
            return false;
        }
        einzelanordnung.setWrongSignatures(true);
        Einzelanordnung savedFlagged = this.save(einzelanordnung);
        if(savedFlagged == null){
            logger.debug("Error Anordnung could not be flagged");
            return false;
        }
        return true;
    }
}
